<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Web Bridge Listener</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdn.jsdelivr.net; connect-src *; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <meta http-equiv="Access-Control-Allow-Origin" content="*">
  <script src="https://cdn.jsdelivr.net/npm/backendless@7/dist/backendless.min.js"></script>
</head>
<body>
  <h2>Listening Bridge Active</h2>

  <script>
    const APP_ID = "9561383D-4BC2-F4F1-FF73-B529BFE77000";
    const API_KEY = "BEE4A193-7ADC-419B-9EB4-202FDA99ACC6";
    let isSending = false; // Prevent loop re-entry
    let isWebViewReady = false; // Track WebView readiness

    function sendMessage(message) {
      if (isSending) {
        console.warn("âš ï¸ Send skipped: Previous send in progress");
        return;
      }
      isSending = true;
      const msgText = typeof message === "object" ? JSON.stringify(message) : String(message);
      console.log("ğŸ“¤ Sending:", msgText);
      try {
        if (window.ReactNativeWebView?.postMessage) {
          window.ReactNativeWebView.postMessage(msgText);
          console.log("ğŸ“¤ Sent via ReactNativeWebView");
        } else {
          window.postMessage(msgText, "*");
          console.log("ğŸ“¤ SENT via window.postMessage");
        }
      } catch (e) {
        console.error("âŒ Failed to send:", e.message);
        console.log("ğŸ” Debug: ReactNativeWebView:", !!window.ReactNativeWebView, "WebView Env:", navigator.userAgent);
        if (/Android|iPhone|iPad/i.test(navigator.userAgent)) {
          console.warn("âš ï¸ WebView error, awaiting readiness");
        } else {
          console.warn("âš ï¸ Browser environment detected, suppressing errors");
        }
      } finally {
        isSending = false;
      }
    }

    function checkWebViewReadiness(callback) {
      const isAndroid = /Android/i.test(navigator.userAgent);
      const maxAttempts = 5;
      let attempts = 0;

      function poll() {
        if (window.ReactNativeWebView || (isAndroid && attempts >= maxAttempts)) {
          isWebViewReady = true;
          console.log("âœ… WebView ready:", !!window.ReactNativeWebView, "Android:", isAndroid);
          sendMessage({ status: "ready", message: "WebView initialized" });
          callback();
        } else {
          attempts++;
          console.log("ğŸ› ï¸ Polling WebView, attempt:", attempts);
          if (attempts < maxAttempts) {
            setTimeout(poll, 1000);
          } else {
            isWebViewReady = true;
            console.warn("âš ï¸ WebView timeout, proceeding with fallback");
            sendMessage({ status: "warning", message: "WebView timeout, using fallback" });
            callback();
          }
        }
      }

      if (isAndroid) {
        window.addEventListener("message", function androidReadyHandler(event) {
          if (event.data === "androidReady") {
            isWebViewReady = true;
            console.log("âœ… Android WebView ready via signal");
            sendMessage({ status: "androidReady", message: "Android WebView initialized" });
            window.removeEventListener("message", androidReadyHandler);
            callback();
          }
        }, { once: true });
      }
      poll();
    }

    function initializeBridge() {
      console.log("ğŸ› ï¸ Initializing WebBridge...");
      sendMessage({ status: "init", message: "Bridge initializing" });
      checkWebViewReadiness(subscribeToChannel);
    }

    async function subscribeToChannel(token, channelName) {
      if (!token || !channelName) {
        console.warn("âŒ Missing token or channelName");
        sendMessage({ status: "error", message: "Missing token or channelName" });
        return;
      }

      try {
        Backendless.initApp(APP_ID, API_KEY);
        Backendless.UserService.setCurrentUserToken(token);
        const channel = Backendless.Messaging.subscribe(channelName);
        channel.addMessageListener((message) => {
          console.log("ğŸ“¤ Forwarding message:", message);
          sendMessage(message);
        });
        console.log("âœ… Subscribed to:", channelName);
        sendMessage({ status: "success", message: `Listening on ${channelName}` });
      } catch (e) {
        console.error("âŒ Subscription error:", e.message);
        sendMessage({ status: "error", message: e.message });
        if (!isWebViewReady) {
          console.log("ğŸ”„ Retrying subscription after 2s");
          setTimeout(() => subscribeToChannel(token, channelName), 2000);
        }
      }
    }

    window.addEventListener("message", async (event) => {
      console.log("ğŸ“© Received message:", event.data);
      let data;

      try {
        data = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
      } catch (e) {
        console.error("âŒ Failed to parse JSON:", e.message);
        sendMessage({ status: "error", message: "Invalid JSON format" });
        return;
      }

      if (data.action === "testBridge") {
        console.log("ğŸ› ï¸ Bridge test: Script loaded");
        sendMessage("BridgeReady");
        return;
      }

      if (!isWebViewReady) {
        console.warn("âš ï¸ WebView not ready, delaying subscription");
        checkWebViewReadiness(() => subscribeToChannel(data.token, data.channelName));
      } else {
        subscribeToChannel(data.token, data.channelName);
      }
    });

    initializeBridge();
    console.log("ğŸ“¡ WebBridge ready");
  </script>
</body>
</html>
