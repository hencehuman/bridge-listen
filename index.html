<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Web Bridge Listener</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdn.jsdelivr.net; connect-src *; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <meta http-equiv="Access-Control-Allow-Origin" content="*">
  <!-- Added cache-busting query parameter to ensure latest SDK -->
  <script src="https://cdn.jsdelivr.net/npm/backendless@7/dist/backendless.min.js?cacheBust=20250522-3"></script>
</head>
<body>
  <h2>Listening Bridge Active</h2>

  <script>
    console.log("ğŸ“¡ Script loading started on iOS - Version 20250522-4");
    try {
      console.log("ğŸ“¡ Initializing environment check...");
      if (!window.console) console = { log: () => {}, error: () => {} }; // Fallback if console is unavailable
      const APP_ID = "9561383D-4BC2-F4F1-FF73-B529BFE77000";
      const API_KEY = "BEE4A193-7ADC-419B-9EB4-202FDA99ACC6";
      const activeChannels = new Map();

      try {
        Backendless.initApp(APP_ID, API_KEY);
        console.log("ğŸ“¡ Backendless initialized successfully with APP_ID:", APP_ID, "API_KEY:", API_KEY.slice(0, 10) + "...");
      } catch (initError) {
        console.error("âŒ Backendless initialization failed:", initError.message);
      }

      function sendMessage(message, retryCount = 0) {
        const msgText = typeof message === "object" ? JSON.stringify(message) : String(message);
        console.log("ğŸ“¤ Sending:", msgText);
        try {
          if (window.ReactNativeWebView?.postMessage) {
            window.ReactNativeWebView.postMessage(msgText);
            console.log("ğŸ“¤ Sent via ReactNativeWebView on iOS");
          } else if (window.parent) {
            window.parent.postMessage(msgText, "*");
            console.log("ğŸ“¤ Sent via parent.postMessage");
          } else {
            console.warn("âš ï¸ No postMessage method available");
          }
          console.log("ğŸ” Debug: UserAgent:", navigator.userAgent, "ReactNativeWebView:", !!window.ReactNativeWebView);
        } catch (e) {
          console.error("âŒ Failed to send:", e.message);
          if (retryCount < 2) {
            console.log("ğŸ”„ Retrying sendMessage, attempt:", retryCount + 1);
            setTimeout(() => sendMessage(message, retryCount + 1), 500);
          } else {
            console.warn("âš ï¸ Max retries reached");
          }
        }
      }

      async function subscribeToChannel(channelName) {
        if (!channelName) {
          console.warn("âŒ Missing channelName");
          sendMessage({ status: "error", message: "Missing channelName" });
          return;
        }

        if (activeChannels.has(channelName)) {
          console.warn("âš ï¸ Already subscribed to:", channelName);
          sendMessage({ status: "error", message: `Already listening wit ${channelName}` });
          return;
        }

        try {
          console.log("ğŸ”„ Attempting subscription as anonymous user to channel:", channelName);
          let channel;
          try {
            channel = Backendless.Messaging.subscribe(channelName);
            console.log("ğŸ” Subscription attempt completed for:", channelName);
          } catch (subscribeError) {
            console.error("âŒ Subscription failure details:", subscribeError.message, subscribeError.code);
            throw new Error(`Subscription failed: ${subscribeError.message}`);
          }

          if (typeof channel.addMessageListener !== "function") {
            throw new Error("addMessageListener is not a function on channel object");
          }
          channel.addMessageListener((message) => {
            console.log("ğŸ“¤ Forwarding message from channel:", channelName, "message:", message);
            sendMessage(message);
          });

          if (typeof channel.addConnectListener === "function") {
            channel.addConnectListener(() => {
              console.log("ğŸ”— WebSocket connected for channel:", channelName);
            });
          } else {
            console.warn("âš ï¸ addConnectListener not supported in this Backendless SDK version");
          }

          activeChannels.set(channelName, channel);
          console.log("âœ… Subscribed to:", channelName, "Active channels:", activeChannels.size);
          sendMessage({ status: "success", message: `Now listening wit ${channelName}` });
        } catch (e) {
          console.error("âŒ Subscription error:", e.message);
          sendMessage({ status: "error", message: e.message });
          activeChannels.delete(channelName);
        }
      }

      function unsubscribeFromChannel(channelName) {
        if (!activeChannels.has(channelName)) {
          console.warn("âš ï¸ Not subscribed to:", channelName);
          sendMessage({ status: "error", message: `Channel ${channelName} not found` });
          return;
        }

        try {
          const channel = activeChannels.get(channelName);
          channel.removeAllMessageListeners();
          activeChannels.delete(channelName);
          console.log("ğŸ›‘ Unsubscribed from:", channelName, "Remaining channels:", activeChannels.size);
          sendMessage({ status: "unsubscribed", message: `Stopped listening wit ${channelName}` });
        } catch (e) {
          console.error("âŒ Unsubscribe error for:", channelName, e.message);
          sendMessage({ status: "error", message: e.message });
        }
      }

      function unsubscribeFromAllChannels() {
        if (activeChannels.size === 0) {
          console.warn("âš ï¸ No active subscriptions to unsubscribe from");
          sendMessage({ status: "error", message: "No active listening wits" });
          return;
        }

        try {
          for (const [channelName, channel] of activeChannels) {
            channel.removeAllMessageListeners();
            console.log("ğŸ›‘ Unsubscribed from:", channelName);
          }
          activeChannels.clear();
          console.log("âœ… Unsubscribed from all channels");
          sendMessage({ status: "unsubscribed", message: "Stopped listening wit all users" });
        } catch (e) {
          console.error("âŒ Unsubscribe error:", e.message);
          sendMessage({ status: "error", message: e.message });
        }
      }

      window.addEventListener("message", async (event) => {
        console.log("ğŸ“© Received message:", event.data, "Source:", event.source, "Origin:", event.origin);
        let data;
        try {
          data = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
          console.log("ğŸ” Parsed data:", data);
        } catch (e) {
          console.error("âŒ Failed to parse JSON:", e.message);
          sendMessage({ status: "error", message: "Invalid JSON format" });
          return;
        }

        if (data.action === "testBridge") {
          console.log("ğŸ› ï¸ Bridge test: Script loaded");
          sendMessage("BridgeReady");
          return;
        }

        if (data.action === "unsubscribe") {
          unsubscribeFromAllChannels();
          return;
        }

        if (data.action === "unsubscribeChannel" && data.channelName) {
          unsubscribeFromChannel(data.channelName);
          return;
        }

        subscribeToChannel(data.channelName);
      }, { passive: true });

      console.log("ğŸ“¡ WebBridge ready on iOS - Version 20250522-4");
    } catch (globalError) {
      console.error("âŒ Global script error:", globalError.message);
    }
  </script>
</body>
</html>
